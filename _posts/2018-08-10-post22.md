---
layout: post
title: study180810
---

<h3>start하는 Activity의 Task</h3>

지금까지 코드를 보고 이해했던 바에 의하면,   
새로 start하는 Activity의 Task는 sourceActivity가 속한 Task 이거나   
개발자가 설정한 Flag에 따라 새로운 Task가 되어야 한다.   
   
코드상으로는 startActivityUnchecked의 getReusableIntentActivity 라는 메소드를 통해,   
start하는 Activity가 이미 존재하는 Task에 포함되어야 하는지의 여부를 검사한다는 것까지 이해하였었다.   
   
그런데, 위 메소드를 통해 단순히 해당 여부를 검사하는 것 뿐만이 아니라,   
이미 존재하는 Task에 start하는 Activity와 동일한 Activity가 존재하는지를 확인하고,   
만약 동일한 Activity가 있다면 그것을 재활용하는 코드가 구현되어있었다.

~~~
/**
 * Decide whether the new activity should be inserted into an existing task. Returns null
 * if not or an ActivityRecord with the task into which the new activity should be added.
 */
private ActivityRecord getReusableIntentActivity() {
    // We may want to try to place the new activity in to an existing task.  We always
    // do this if the target activity is singleTask or singleInstance; we will also do
    // this if NEW_TASK has been requested, and there is not an additional qualifier telling
    // us to still place it in a new task: multi task, always doc mode, or being asked to
    // launch this as a new task behind the current one.
    boolean putIntoExistingTask = ((mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0 &&
            (mLaunchFlags & FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
            || mLaunchSingleInstance || mLaunchSingleTask;
    // If bring to front is requested, and no result is requested and we have not been given
    // an explicit task to launch in to, and we can find a task that was started with this
    // same component, then instead of launching bring that one to the front.
    putIntoExistingTask &= mInTask == null && mStartActivity.resultTo == null;
    ActivityRecord intentActivity = null;
    if (mOptions != null && mOptions.getLaunchTaskId() != -1) {
        final TaskRecord task = mSupervisor.anyTaskForIdLocked(mOptions.getLaunchTaskId());
        intentActivity = task != null ? task.getTopActivity() : null;
    } else if (putIntoExistingTask) {
        if (mLaunchSingleInstance) {
            // There can be one and only one instance of single instance activity in the
            // history, and it is always in its own unique task, so we do a special search.
           intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,
                   mStartActivity.isHomeActivity());
        } else if ((mLaunchFlags & FLAG_ACTIVITY_LAUNCH_ADJACENT) != 0) {
            // For the launch adjacent case we only want to put the activity in an existing
            // task if the activity already exists in the history.
            intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,
                    !mLaunchSingleTask);
        } else {
            // Otherwise find the best task to put the activity in.
            intentActivity = mSupervisor.findTaskLocked(mStartActivity, mSourceDisplayId);
        }
    }
    return intentActivity;
}
~~~

지난번에는 주석만 읽고 넘어갔었는데, 코드를 자세히 보니 findActivityLocked(또는 findTaskLocked)라는 메소드를 통해   
start 하려는 Activity와 같은 Activity를 찾아내는 코드가 구현이 되어있었다.   
이 메소드는 ActivityStackSupervisor에서 다시 ActivityStack에 구현된 findActivityLocked 메소드를   
호출하는 내용이 작성되어있었다.   

~~~
/**
 * Returns the first activity (starting from the top of the stack) that
 * is the same as the given activity.  Returns null if no such activity
 * is found.
 */
ActivityRecord findActivityLocked(Intent intent, ActivityInfo info,
                                  boolean compareIntentFilters) {
    ComponentName cls = intent.getComponent();
    if (info.targetActivity != null) {
        cls = new ComponentName(info.packageName, info.targetActivity);
    }
    final int userId = UserHandle.getUserId(info.applicationInfo.uid);

    for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
        final TaskRecord task = mTaskHistory.get(taskNdx);
        final ArrayList<ActivityRecord> activities = task.mActivities;

        for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
            ActivityRecord r = activities.get(activityNdx);
            if (!r.okToShowLocked()) {
                continue;
            }
            if (!r.finishing && r.userId == userId) {
                if (compareIntentFilters) {
                    if (r.intent.filterEquals(intent)) {
                        return r;
                    }
                } else {
                    if (r.intent.getComponent().equals(cls)) {
                        return r;
                    }
                }
            }
        }
    }

    return null;
}
~~~

보통은 주어진 ActivityInfo에 포함된 ComponentName와   
ActivityStack에 저장된 Activity들의 ComponentName의 일치 여부를 검사한다.   

~~~
if (reusedActivity != null) {
    // When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but
    // still needs to be a lock task mode violation since the task gets cleared out and
    // the device would otherwise leave the locked task.
    if (mSupervisor.isLockTaskModeViolation(reusedActivity.getTask(),
            (mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))
                    == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
        mSupervisor.showLockTaskToast();
        Slog.e(TAG, "startActivityUnchecked: Attempt to violate Lock Task Mode");
        return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }

    if (mStartActivity.getTask() == null) {
        mStartActivity.setTask(reusedActivity.getTask());
    }
    if (reusedActivity.getTask().intent == null) {
        // This task was started because of movement of the activity based on affinity...
        // Now that we are actually launching it, we can assign the base intent.
        reusedActivity.getTask().setIntent(mStartActivity);
    }

    // This code path leads to delivering a new intent, we want to make sure we schedule it
    // as the first operation, in case the activity will be resumed as a result of later
    // operations.
    if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0
            || isDocumentLaunchesIntoExisting(mLaunchFlags)
            || mLaunchSingleInstance || mLaunchSingleTask) {
        final TaskRecord task = reusedActivity.getTask();

        // In this situation we want to remove all activities from the task up to the one
        // being started. In most cases this means we are resetting the task to its initial
        // state.
        final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,
                mLaunchFlags);

        // The above code can remove {@code reusedActivity} from the task, leading to the
        // the {@code ActivityRecord} removing its reference to the {@code TaskRecord}. The
        // task reference is needed in the call below to
        // {@link setTargetStackAndMoveToFrontIfNeeded}.
        if (reusedActivity.getTask() == null) {
            reusedActivity.setTask(task);
        }

        if (top != null) {
            if (top.frontOfTask) {
                // Activity aliases may mean we use different intents for the top activity,
                // so make sure the task now has the identity of the new intent.
                top.getTask().setIntent(mStartActivity);
            }
            deliverNewIntent(top);
        }
    }

    sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity);

    reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);

    final ActivityRecord outResult =
            outActivity != null && outActivity.length > 0 ? outActivity[0] : null;

    // When there is a reused activity and the current result is a trampoline activity,
    // set the reused activity as the result.
    if (outResult != null && (outResult.finishing || outResult.noDisplay)) {
        outActivity[0] = reusedActivity;
    }

    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
        // We don't need to start a new activity, and the client said not to do anything
        // if that is the case, so this is it!  And for paranoia, make sure we have
        // correctly resumed the top activity.
        resumeTargetStackIfNeeded();
        return START_RETURN_INTENT_TO_CALLER;
    }
    setTaskFromIntentActivity(reusedActivity);

    if (!mAddingToTask && mReuseTask == null) {
        // We didn't do anything...  but it was needed (a.k.a., client don't use that
        // intent!)  And for paranoia, make sure we have correctly resumed the top activity.
        resumeTargetStackIfNeeded();
        if (outActivity != null && outActivity.length > 0) {
            outActivity[0] = reusedActivity;
        }

        return START_TASK_TO_FRONT;
    }
}
~~~

Activity의 재활용 부분 코드. 아침에 이어서 
* * *
